# Session 1: Table Columns and Data Types

## Overview
A database is a collection of tables of data. Each table consists of one or more *columns* that describe the data in the column. This consists of a *name* (eg "firstname" or "age") and a type (string, number, etc). Columns can contain more advanced information as well, but we will explore that in a later section. For this session, we will explore some of the available data types.


ðŸ§  Note: Columns may be allowed to be empty, in which case they have a *NULL* value. We will return to this later. 


## Basic Data Types
### Boolean Values
A column of type *boolean* will allow values of data to be logical *True* or *False*. From a storage perspective, Booleans are nice and small since its value is implemented as a binary "on" or "off" value.

### Text Strings
Chunks of text are typically referred to as "strings". A string is simply a list of characters. Characters take up storage space and to keep databases as small as possible, most relational databases allow you to be more specific about the size of the data stored in a column. If you want to store paragraphs of free form text of highly variable length you might use a `text` type. Whereas if you are storing short chunks of text (such as a firstname), you might consider using a `varchar`. The later will *allocate* less space.

### Numbers
Like strings, numbers can be stored in multiple ways for optimal results. A whole number (such as age) is an *integer*. Integers can be signed or unsigned, meaning negative numbers are allowed or not. Also, columns of type integer can have an allowed size to *allocate* the appropriate amount of space. In postgres, the different options are represented in *bytes*. The largest signed int that can be stored in a column of type `int2` is 32,767. Similarly, the largest signed int that can be stored in a column of type `int8` is 9,223,372,036,854,775,807.

Another type of number that can be stored are decimal numbers (also called a "float" or "double"). Under the hood these are stored in two parts: the whole number and the decimal part. These can also be signed or unsigned. Also, depending on the "precision" of the decimal, they can require different amounts of bytes. Postgres offers two flavors: `float4` that uses 4 bytes of storage and `float8` which uses 8 bytes of storage.

ðŸ§  Note: Fractions cannot be directly store in most database systems.

ðŸ§  Note: Numbers are ideal for numerical data that needs mathematical operations applied such as inequalities, summation, averaging, etc. 


### Dates and Times
Many databases implement a convenience column type to work with dates and times. These will often include helpful options to format the dates, prevent illogical dates (January 35th), and allow for mathematical operations like inequality comparison, sorting, etc.

Postgres offers five types for specific needs: `date` (which only stores a calendar date), `time` and `timetz` (which only stores the time of date with or without timezone respectively), and `timestamp` and `timestamptz` (which stores a date and time with our without timezone respectively). 

ðŸ§   Under the hood, timestamps are typically stored as integers representing the number of seconds since January 1st, 1970. This universal but arbitrary date is also known as the "epoch". For an interesting read, check out the "Epocalypse" which will help you understand the importance of the column size for numbers discussed above.

ðŸ§  Time Zones are represented as an offset from the Prime Meridian in Greenwich England. This timezone is GMT (Greenwich Mean Time) or more often when working with datestamps in computing referred to as simply UTC which is short for "Universal Time Coordinated". A time or timestamp without timezone information is stored with 0 timezone.


## Advanced Data Types
There are a few advanced types that are worth noting. Some database implementations might have their own custom types. Here are a few that Postgres implements.

### UUID
A uuid is a "universal id". As defined in the [Postgres docs](https://www.postgresql.org/docs/9.1/datatype-uuid.html), "This identifier is a 128-bit quantity that is generated by an algorithm chosen to make it very unlikely that the same identifier will be generated by anyone else in the known universe using the same algorithm. Therefore, for distributed systems, these identifiers provide a better uniqueness guarantee than sequence generators, which are only unique within a single database." 

### Json Jsonb
JSON is a standard for storing data into a *portable object*. While a single number, boolean, etc can technically be stored in JSON, it is more commonly used to store more complex data structures like lists of numbers or complex objects that contain a variety of fields. We will possibly cover `json` and `jsonb` column types later.

## Other Column Concepts
In addition to data types, columns can have other information or constraints. 

### NULL
As mentioned above, a row in a column may not have a value for a specific column. The column can be told how to handle this. If a column does not allow null values and data tries to be added to the table where no value for the column is provided, an error will occur. This is useful for maintaining data integrity.

### Default Value
A column can define a default value. If a column does not allow null values as per above, but defines a default value, the default value will be used. 

### Uniqueness
A column can enforce uniqueness of values within the column. For example, if a table of employees contains an badge number, we may make that column enforce uniqueness to prevent duplicate employees. 

### Primary Keys
Without delving too much into how relationships work with relational databases, a primary key is used as the unique id for a row in a table. If a column is designated as a primary key, the values typically cannot be null and must be unique. The column can typically be of any type although columns of type `int8` or `uuid` work best for this. 


## Closing
We now know that a database table is a series of rows and columns of data with each column defining various constraints such as uniqueness or type. In the next section we will start diving into actually querying data using a Structured Query Language (SQL). 


